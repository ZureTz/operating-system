# FIFO, OPT, LRU and CLOCK algorithms

 This is a simple  program that implements the FIFO, OPT, LRU, and CLOCK  page replacement algorithms presented in Chapter 9.

## Compile and Run

1. Compile

```bash
g++ -std=c++20 main.cc -o main
```

2. Execute the program

```
./main
```

## Features

This C++ program that simulates four different page replacement algorithms: FIFO (First In, First Out), OPT (Optimal), LRU (Least Recently Used), and CLOCK.

Here's a breakdown of the code:

1. **Function Definitions**

- `generateReferenceString`: This function (not provided in the code snippet) generates a random sequence of page references, which simulates the memory access pattern of a process.
- `FIFOImpl`: This function implements the FIFO algorithm. It maintains a queue of page frames and replaces the oldest page (the one that entered the queue first) when a page fault occurs.
- `OPTImpl`: This function implements the OPT algorithm, which is an optimal algorithm but not practical  since it requires knowing the entire future reference string. It replaces the page that will not be used for the longest time in the future.
- `LRUImpl`: This function implements the LRU algorithm. It keeps track of the most recently used pages and replaces the least recently used page when a page fault occurs.
- `CLOCKImpl`: This function implements the CLOCK algorithm. It uses a circular queue of page frames and a "clock" hand. The hand keeps iterating through the frames. If a frame's reference bit is set, the hand moves to the next frame. If the reference bit is not set, that frame is chosen for replacement. The reference bit is then set for the new page loaded into the frame.
- `showInfo`: This function prints the provided reference string.

2. **Main Function**

- The `main` function first defines the size of the reference string (`REF_STR_SIZE`) and the number of available page frames (`FRAME_SIZE`).

- It then generates a random reference string using `generateReferenceString`.

- It shows the reference string using `showInfo`.

- For each algorithm (FIFO, OPT, LRU, CLOCK), it calls the corresponding implementation function 
  
    - `FIFOImpl`
    - `OPTImpl`
    - `LRUImpl`
    - `CLOCKImpl`
    
    with the reference string and frame size as arguments.
    
    - Each implementation function simulates the algorithm by iterating through the reference string and keeping track of the page frames.
    - It checks for page faults and replaces pages according to the specific algorithm's logic.
    - It logs the state of the page frames after each reference.

## Expected Results

This is one of the results since the `referenceString` is generated by random number generator.

```bash
The reference string is: [7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1] 

FIFO page replacement algorithm: 
No page is in the page frame, the page frame is: [-1, -1, -1] 
Page 7 reference, bring to the page frame: [7, -1, -1] 
Page 0 reference, bring to the page frame: [7, 0, -1] 
Page 1 reference, bring to the page frame: [7, 0, 1] 
Page 2 reference, page fault, 7 is the first in, replace 7: [2, 0, 1] 
Page 0 reference, no page fault.
Page 3 reference, page fault, 0 is the first in, replace 0: [2, 3, 1] 
Page 0 reference, page fault, 1 is the first in, replace 1: [2, 3, 0] 
Page 4 reference, page fault, 2 is the first in, replace 2: [4, 3, 0] 
Page 2 reference, page fault, 3 is the first in, replace 3: [4, 2, 0] 
Page 3 reference, page fault, 0 is the first in, replace 0: [4, 2, 3] 
Page 0 reference, page fault, 4 is the first in, replace 4: [0, 2, 3] 
Page 3 reference, no page fault.
Page 2 reference, no page fault.
Page 1 reference, page fault, 2 is the first in, replace 2: [0, 1, 3] 
Page 2 reference, page fault, 3 is the first in, replace 3: [0, 1, 2] 
Page 0 reference, no page fault.
Page 1 reference, no page fault.
Page 7 reference, page fault, 0 is the first in, replace 0: [7, 1, 2] 
Page 0 reference, page fault, 1 is the first in, replace 1: [7, 0, 2] 
Page 1 reference, page fault, 2 is the first in, replace 2: [7, 0, 1] 

OPT page replacement algorithm: 
No page is in the page frame, the page frame is: [-1, -1, -1] 
Page 7 reference, bring to the page frame: [7, -1, -1] 
Page 0 reference, bring to the page frame: [7, 0, -1] 
Page 1 reference, bring to the page frame: [7, 0, 1] 
Page 2 reference, page fault, 7 will not be used for the longest, replace 7: [2, 0, 1] 
Page 0 reference, no page fault.
Page 3 reference, page fault, 1 will not be used for the longest, replace 1: [2, 0, 3] 
Page 0 reference, no page fault.
Page 4 reference, page fault, 0 will not be used for the longest, replace 0: [2, 4, 3] 
Page 2 reference, no page fault.
Page 3 reference, no page fault.
Page 0 reference, page fault, 4 will not be used for the longest, replace 4: [2, 0, 3] 
Page 3 reference, no page fault.
Page 2 reference, no page fault.
Page 1 reference, page fault, 3 will not be used for the longest, replace 3: [2, 0, 1] 
Page 2 reference, no page fault.
Page 0 reference, no page fault.
Page 1 reference, no page fault.
Page 7 reference, page fault, 2 will not be used for the longest, replace 2: [7, 0, 1] 
Page 0 reference, no page fault.
Page 1 reference, no page fault.

LRU page replacement algorithm: 
No page is in the page frame, the page frame is: [-1, -1, -1] 
Page 7 reference, bring to the page frame: [7, -1, -1] 
Page 0 reference, bring to the page frame: [7, 0, -1] 
Page 1 reference, bring to the page frame: [7, 0, 1] 
Page 2 reference, page fault, 7 is least used, replace 7: [2, 0, 1] 
Page 0 reference, no page fault.
Page 3 reference, page fault, 1 is least used, replace 1: [2, 0, 3] 
Page 0 reference, no page fault.
Page 4 reference, page fault, 2 is least used, replace 2: [4, 0, 3] 
Page 2 reference, page fault, 3 is least used, replace 3: [4, 0, 2] 
Page 3 reference, page fault, 0 is least used, replace 0: [4, 3, 2] 
Page 0 reference, page fault, 4 is least used, replace 4: [0, 3, 2] 
Page 3 reference, no page fault.
Page 2 reference, no page fault.
Page 1 reference, page fault, 0 is least used, replace 0: [1, 3, 2] 
Page 2 reference, no page fault.
Page 0 reference, page fault, 3 is least used, replace 3: [1, 0, 2] 
Page 1 reference, no page fault.
Page 7 reference, page fault, 2 is least used, replace 2: [1, 0, 7] 
Page 0 reference, no page fault.
Page 1 reference, no page fault.

CLOCK page replacement algorithm: 
No page is in the page frame, the page frame is: [-1, -1, -1] 
Page 7 reference, bring to the page frame: [7, -1, -1] 
Page 0 reference, bring to the page frame: [7, 0, -1] 
Page 1 reference, bring to the page frame: [7, 0, 1] 
Page 2 reference, page fault, 7's reference bit is 0, replace 7: [2, 0, 1] 
Page 0 reference, no page fault.
Page 3 reference, page fault, 1's reference bit is 0, replace 1: [2, 0, 3] 
Page 0 reference, no page fault.
Page 4 reference, page fault, 2's reference bit is 0, replace 2: [4, 0, 3] 
Page 2 reference, page fault, 3's reference bit is 0, replace 3: [4, 0, 2] 
Page 3 reference, page fault, 4's reference bit is 0, replace 4: [3, 0, 2] 
Page 0 reference, no page fault.
Page 3 reference, no page fault.
Page 2 reference, no page fault.
Page 1 reference, page fault, 3's reference bit is 0, replace 3: [1, 0, 2] 
Page 2 reference, no page fault.
Page 0 reference, no page fault.
Page 1 reference, no page fault.
Page 7 reference, page fault, 1's reference bit is 0, replace 1: [7, 0, 2] 
Page 0 reference, no page fault.
Page 1 reference, page fault, 2's reference bit is 0, replace 2: [7, 0, 1] 
```

The output shows the results of running a program that simulates four page replacement algorithms: FIFO (First In, First Out), OPT (Optimal), LRU (Least Recently Used), and CLOCK.

1. **FIFO (First In, First Out)**

    - FIFO replaces the oldest page in the frame whenever a page fault occurs.

    - This can lead to unnecessary page faults if a recently used page is evicted to make room for a new one.

    - In this example, FIFO has 15 page faults.

2. **OPT (Optimal)**

    - OPT knows the entire reference string in advance and replaces the page that will not be used for the longest time in the future.
    - This is not achievable in a real system but serves as a benchmark for optimal performance.
    - OPT has only 9 page faults, which is the minimum possible for this reference string.

3. **LRU (Least Recently Used)**

    - LRU keeps track of the most recently used pages and replaces the least recently used page when a page fault occurs.
    - This strategy aims to keep frequently accessed pages in memory.
    - LRU has 12 page faults in this example, performing better than FIFO but not as well as OPT.
4. **CLOCK**
    - CLOCK uses a circular queue and a "clock" hand to decide which page to replace.
    - The algorithm is more complex than FIFO or LRU but aims to balance keeping recently used pages and avoiding unnecessary evictions.
    - CLOCK has 11 page faults in this example, performing similarly to LRU.

## References

- [c++ - Generate random numbers using C++11 random library - Stack Overflow](https://stackoverflow.com/questions/19665818/generate-random-numbers-using-c11-random-library)

- [OS hw9_34. write FIFO and LRU page-replacement… | by Chien-lin.Tseng | My learning note | Medium](https://medium.com/我的learning-note/os-hw9-34-51c876e6a8e9)